


Spring 이라는 용어는 여러 맥락에서 사용된다. 기본적으로 Spring 이라 함은 스프링 프로젝트의 전체 제품군을 의미하지만, 모든 스프링 프로젝트의 근간이 되는 Spring Framework  를 지칭하는 의미로도 자주 사용된다. 이 글에서는 스프링의 기본이 되는 Spring Framework 를 스프링이라 칭하고, Spring Framework 에 대해 알아 볼 것이다.

Spring Framework는, Spring이라는 단어 그대로 봄이라는 의미에서 이름을 따온 프레임워크다. 어떤 면에서 봄인가 하는 것을 알아보려면, 스프링이 등장하기 이전 웹 개발 생태계를 알아볼 필요가 있다.
스프링 등장 이전 자바 웹 개발은 EJB(Enterprise Java Bean) 이라고 하는 서버 어플리케이션에 의해 이뤄졌었다. EJB는 분리된 비즈니스 계층을 제공하거나 트랜잭션 관리 등 개발에 있어 다양한 편의가 지원되는 장점이 있었다. 그렇지만 실행시간이 길고 초기 설정이 매우 복잡하며 EJB 컨테이너에 종속적이기 때문에 테스트가 어려운 등 실제로는 개발 생산성을 떨어뜨리는 단점들이 많았기 때문에, 개발 시간을 크게 단축시키지 못하고 개발자가 비즈니스 로직보다 다른 부분에 더 많은 시간을 투자하는 등 여러 문제가 있었다. 

스프링은 이런 EJB의 여러 문제들을 해결하면서, 개발 생태계의 겨울을 끝내기 위해 등장했다.
스프링은 다양한 방면에서 EBJ가 품고 있던 문제들을 개선시켰고, 개발자들이 개발 외적인 문제로 생기는 고통으로부터 자유로울 수 있도록 도와주었다. 다음은 EJB에서 스프링이 등장함으로써 어떤 점들이 개선됐는지 정리한 것이다.

 

 - 경량 컨테이너
스프링은 EJB에 비해 가벼운 컨테이너와 간소한 설정으로 개발 편의성을 증대시켰고, POJO(Plan Old Java Object) 를 사용해 개발하도록 함으로써 단순성을 제공한다.

 - 의존성 주입
스프링은 객체들 간의 의존성을 외부에서 주입함으로써 객체 간의 결합도를 낮추고 코드의 유연성을 확보하였으며 테스트하기 더 쉬운 환경을 제공한다. EBJ에도 의존성을 주입하는 개념이 있었지만, 스프링에서 더 유연하고 간편한 방법을 사용한다.

 - Spring AOP
스프링은 관점 지향 프로그래밍(AOP) 를 지원하여 트랜잭션 관리와 같은 코드의 횡단 관심사(공통 관심사)를 분리하고, 개발자가 비즈니스 로직에 더 집중할 수 있도록 도와준다.

 - Annotation 기반 구성
xml 기반 설정으로 구성이 복잡하던 EJB 환경에 비해 스프링에서는 빈 등록, 의존성 주입, 구성 설정 등 다양한 작업을 Annotation으로 수행할 수 있도록 개선된 환경을 제공한다.



그렇다면 스프링이 어떻게 위와 같은 개선들을 달성할 수 있었는지, 스프링을 관통하는 핵심 키워드들과 함께 알아보자.
(그러나 이런 스프링도 여러 문제들이 있었기에 이것들을 또 한번 개선한 스프링 2.0버전 격인 스프링 부트가 등장했는데, 처음 공부하는 사람들의 경우 스프링과 스프링 부트의 개념을 헷갈려하는 경우가 있어 두 개념의 차이를 글로 정리했다.)

 

 

IOC (Inversion Of Control)
IOC 는 Inversion Of Control 의 약자로, 직역하여 제어의 역전 이라는 뜻이 된다. 즉 IOC 는 현재 코드의 흐름을 코드 내에서 제어하지 않고 외부에서(스프링의 경우 IOC 컨테이너에서) 제어하는 것을 말한다. (프레임워크가 IOC 가 반영된 기술의 대표적인 사례이기 때문에, 흔히들 프레임워크에서 개발자 코드를 호출하며 제어하는 것을 예로 들어 설명하곤 한다)  이렇게 설명하면 "컨트롤을 역전시키는 어떤 기술" 처럼 들릴 수 있으나, 여기서 말하는 IOC 는 따라야 하는 "원칙" 이다. 이 IOC 를 따르기 위해 스프링에서는 IOC 컨테이너(스프링 컨테이너)를 사용하며 DI와 같은 디자인 패턴을 사용한다.
그렇다면

"의존 역전 원칙(IOC) 을 따르는 방법으로, 코드 내부가 아닌 외부에서 흐름을 제어하기 위해 스프링은 IOC 컨테이너를 사용하며, 그 핵심 전략으로 종속성을 주입하는 디자인 패턴인 DI(Dependency Injection)를 사용한다."

라고 대략적인 흐름을 생각해 볼 수 있겠다.
IOC 컨테이너는 스프링 프레임워크의 기술 중 가장 핵심 기술이라고 봐도 되며, 후에 다룰 Spring AOP(Aspect Oriented Programming, 관점 지향 프로그래밍) 와도 밀접하게 연관되어 있다. 일반적으로 '스프링 컨테이너' 라 함은 IOC 컨테이너와 같은 의미로 사용되는데, 이에 대한 조금 깊은 내용은 다른 글에서 다루고 있다. 간단히 말하면 IOC 컨테이너는 스프링 어플리케이션이 실행됨과 동시에 생성되는 컨테이너로, 빈들의 생성과 생명주기, 의존성 관리 등을 담당하는 역할을 한다.


why IOC?
여기까지 알아봤다면 다음과 같은 의문이 들 수 있다.
제어의 흐름이 개발자 코드에서 IOC 컨테이너로 넘어가는 것까진 알겠다. 그런데 이로써 무슨 이득을 얻지?

IOC는 제어의 흐름을 컨테이너로 위임하는 것 자체만으로 개발자에게 비즈니스 로직에 집중하게끔 할 수 있다는 장점을 지니고 있다. 그 외에도 코드 결합도를 느슨하게 하여 변경에 유연하고 확장성 있는 코드를 만들 수 있으며, 유지 보수에 용이하고 가독성이 좋아지는 등 여러 장점들이 있다. 스프링에서는 DI 를 적용함으로써 테스트 용이성 등 더 많은 이점을 찾을 수 있는데, 더 자세한 내용은 다른 글에서 다루기로 한다. 


간단하게 IOC와 IOC 컨테이너의 개념에 대해서 알아봤다. 그렇다면 스프링에서는 어떻게 IOC 원칙을 준수하는가? 하는 질문을 던질 수 있는데, 이 답을 DI(Dependency Injection, 의존성 주입) 에 대해 알아보면서 찾을 수 있을 것 같다.


 

DI (Dependency Injection)
DI 는 스프링에서 IOC 원칙을 실현하기 위해 사용하는 여러 전략들 중 가장 대표적인 디자인 패턴이라고 할 수 있다. 직역하면 의존성을 주입한다는 뜻인데, 의존성을 주입한다는 말이 조금 어렵게 느껴질 수 있다. 의존한다는 것이 사전적으로는,
"A 객체가 B 객체를 의존하고 있을 경우, B 객체의 변화가 A 객체에도 영향을 미친다."
라고 정의할 수 있는데, 달리 말하면
"B객체의 변화가 A 객체에 영향을 미칠 경우, A 가 B 를 의존하고 있다."
와 같다.

처음 DI 를 공부할 때는, 이렇게 풀어 쓴 글들을 봐도 금방 이해가 되지 않았다. 아마 이 개념을 처음 접한다면 대부분이 나와 같을 거라고 생각하는데, 내가 이 개념을 이해하는데 큰 도움이 됐던 김영한님의 말씀을 차용하면 의존성은 다음과 같이 이해할 수 있다.

A가 B를 의존한다는 것은, A가 B를 알고 있다 는 말과 같다. (학교에서 모르는 사람의 체육복을 빌려 입을 수는 없지만, 알고 있는 사람의 체육복을 빌려서 입을 수 있는 것을 생각하면 조금 이해하기 쉬울 것이다.)

위에서 이해한 대로라면 의존성이 생긴다는 것은, 객체 A와 객체 B가 아는 사이가 된다는 것이다. 그렇다면 의존성 주입은? 외부에 의해 아는 사이가 되는 것이다. 스프링의 경우, 스프링 컨테이너에서 관리하는 빈들을 주입하여 객체 간에 의존성을 가지도록 한다고 볼 수 있다. 이렇게 의존성을 자신이 선언하지 않고 외부에서 주입받는 것을 의존성 주입이라고 하며, 의존성을 객체 자신의 코드 내부에서 정의하지 않고 외부로부터 주입받아 사용하기 때문에 제어 역전이 자연히 따라오게 된다.
(그러나 대표적이라고 해서 DI가 IOC 를 실현하는 스프링의 유일무이한 전략인 것으로 이해하면 안된다. IOC 컨테이너만 봐도 빈의 등록과 생명주기 같은 것들을 직접 관리하며 코드 흐름을 제어하고, 그런 기술들과 어우러져 의존성을 외부에서 주입하는 패턴이 Dependency Injection 이며 그로 인해 얻어지는 다양한 이점들이 스프링이 널리 사용되는 프레임워크인 핵심적인 이유이기에 스프링의 대표 키워드라 불리는 것이다.)

DI 에는 여러 가지 형태가 있는데, 대표적으로 생성자 주입, 필드 주입, setter 주입 등이 그것이다. 각 주입 방법에 대한 자세한 내용은 다른 글에서 다루었다. 이 글에서는 구체적으로 어떻게 의존성을 주입하는지, 각각 주입 방식에는 어떤 장단점이 따르는지 등은 다루지 않고, IOC를 따르는 전략으로써의 DI와 간략한 개념에 대해서만 알아봤다.

 

IOC / DI 이해
IOC가 뭔지, DI가 어떤 것인지 개념적으로 알아봤다고 해도, 실제로 어떤 식으로 적용되는 것인지 이해가 가지 않을 수도 있다. 간단하게 이해를 돕자면,

 


PostService
 


비즈니스 로직을 갖고 있는 PostService 라는 클래스가 있다고 하자. 이 서비스를 주입받아 서비스의 메서드를 사용하는 컨트롤러는 다음과 같다.

 


PostService 를 주입받은 PostController
 


박스로 표시된 부분이 생성자 주입을 통해 PostService 를 주입받는 부분인데, 우리가 코드 어디에서도 PostService 를 인스턴스화 한적 없는데도 Controller는 외부에서 postService 객체를 주입받아서 문제없이 사용하고 있다. 

이는 어플리케이션이 시작됨과 동시에 IOC 컨테이너에서 빈들을 등록하기 때문인데, 빈을 등록한다는 것은 곧 클래스를 객체(Bean)로 만들어 컨테이너에서 관리하는 것을 뜻한다. 빈 객체가 생성되면 해당 빈이 의존하고 있는 다른 빈들을 주입하면서 의존성 주입이 일어나게 된다. 위 예의 경우 생성자 주입으로, 생성 시점에 의존하고 있는 PostService 빈이 주입됨을 알 수 있다.

 

 

AOP/ Spring AOP(Aspect Oriented Programming)
스프링을 관통하는 또다른 핵심 키워드인 AOP 이다. Aspect Orineted Programming 의 약자로, 관점(Aspect) 지향 프로그래밍 이라는 뜻을 담고 있다. 그러면 관점이 뭐지? 관점은 "관심사" 정도로 표현할 수 있는데, AOP 에서 말하는 관심사는 주로 "횡단 관심사" 를 말한다. 그러나 딱히 직관적이지 않은 단어다. 그래서 처음엔 이해하는게 좀 어려웠던 것 같다.

횡단 관심사가 어떤 것인지 말로 하는것보다, 가장 직관적으로 이해되는 이미지를 가져와 봤다.



출처 : IT 용어위키
 


보면 계좌이체와 입출금, 이자계산 등은 우리가 알고 있는 비즈니스 로직이다. 그것을 그림에선 핵심 관심이라고 표현했다.
그리고 로깅, 보안, 트랜잭션이라는 횡단 관심도 보이는데, 말 그대로 여러 개의 핵심 관심에 걸쳐서 횡단으로 누워 있다. 그래서 횡단 관심이라고 표현한다. 그렇다면 횡단 관심을 왜 핵심 관심과 분리하지?

로깅, 보안, 트랜잭션은 물론 중요하고 없어서는 안될 기능이지만, 비즈니스 로직에 포함되지는 않고 또 여러 모듈에 중복되어 걸쳐있다. 이것을 비즈니스 로직(핵심 관심)과 분리해야 하는 이유는 여러가지가 있다. 우선 여러 모듈에 걸쳐있는 횡단 관심사를 별도의 모듈로 분리하면서 중복이 제거되고, 이에 따라 읽기 쉬운 코드가 되면서 가독성이 좋아진다. 또 관심사끼리 분리되어 있기 때문에 변경과 확장에 유연하고, 각각 로직을 독립적으로 테스트할 수 있게 되어 테스트에도 효과적이다. 이를 정리해보면 다음과 같다.

중복 제거
여러 모듈에 걸쳐 있는 횡단 관심사를 별도의 모듈로 분리함으로써, 각 비즈니스 로직에서의 중복이 제거되고, 비즈니스 로직만 남은 코드는 깔끔해지며 이해하기 쉬운 코드가 된다.

유지보수성 향상
비즈니스 로직 또는 전체 횡단 관심사의 수정이 필요할 때 해당 모듈만 변경하면 되므로 유지 보수가 쉬워진다. 

테스트 용이성
비즈니스 로직과 횡단 관심사가 분리되면서 각각을 독립적으로 테스트 할 수 있게 된다.
 

이것이 AOP 를 적용하는 이유이다. AOP는 설계 원칙이나 기술이 아닌 프로그래밍 기법으로, 비슷한 맥락인 OOP(객체지향 프로그래밍) 와 상충하는 개념이라고 생각할 수 있는데, Spring 공식 문서에서는 OOP와 AOP를 상호 보완되는 개념으로 설명하고 있다.즉 AOP 를 활용함으로써 더 객체지향적인 코드를 설계할 수 있는 것이다.

 

 

Spring AOP
지금까지 알아본 AOP는 비단 스프링에만 국한되는 개념이 아닌, 말 그대로 프로그래밍 기법이다. 스프링에서 AOP를 적용할 때는 스프링 AOP라는 조금 다른 용어를 사용하는데, 다른 개념인 것은 아니고 스프링에 적용할 수 있게끔 조금 더 특화된 AOP 기술을 사용한다고 보면 된다. 그렇다면 일반적인 (자바의)AOP와 스프링 AOP가 어떻게 다른지 간단히 파헤쳐보자.

일반적으로 자바에서는 AOP 를 적용하기 위해 AspectJ 라는 확장을 사용한다. 스프링은 자바 기반 프레임워크이기 때문에, AspectJ 를 기반으로 하면서 조금 더 단순화되고 독자적인 AOP 구현을 제공한다. 가장 큰 차이점은 Aspect(관점 = 횡단 관심사) 의 적용 시점인데, AspectJ 는 컴파일 시점 또는 클래스 로드 시점에 적용하지만 Spring AOP 는 프록시 패턴을 통해 런타임에 Aspect 를 적용한다. 또 AspectJ 는 풍부한 포인트컷 표현식으로 다양한 조건을 사용하여 Aspect 를 적용할 수 있고, 따라서 복잡한 AOP 요구사항을 해결하는데 적합하다. Spring AOP 는 AspectJ 보다 간편한 대신 제한적인 포인트컷 표현식을 사용하기 때문에, Spring 프로젝트에서 간결하게 AOP 요구사항을 처리할 때 사용한다. 이는 Spring AOP가 AspectJ 를 기반으로 만들어졌음에도  Sprnig 환경에 맞는 독자적인 방법으로 AOP 를 구현하도록 설계되었음을 뜻한다.

 

위에 언급했듯이 AspectJ 와 Spring AOP 는 사용 목적도 적용 방식도 조금씩 차이가 있다. 이것은 Spring AOP 가 프록시 패턴을 사용하는 것과 관련이 있는데, Spring AOP 의 두드러지는 특징인 프록시 패턴이 어떻게 AOP에 적용되는지에 대해 간결하게 알아보면 다음과 같다.
(아래 글은 예전 @Transactional 관련 트러블슈팅 중 정리한 글의 일부를 가져온 것이다.)

더보기
 

스프링은 이처럼 대리 객체를 사용해서 로깅이나 트랜잭션 등의 관심사를 해결하고, 개발자에게는 비즈니스 로직에만 집중할 수 있도록 한다. 스프링이 AspectJ와 다르게 간결하게 사용할 수 있는 프록시 패턴을 사용하고 있는 점 역시 IOC 컨테이너 덕분인데, 이 부분 때문에 또한 Spring AOP 는 프레임워크에 종속적인 기술이라는 한계를 가진다. 컨테이너가 없는 환경에서는 더 강력한 AOP 도구인 AspectJ 를 사용하는 것도 여러 장점이 있으니 고려해 볼 수 있겠다.

 
